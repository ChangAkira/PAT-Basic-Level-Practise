1003 我要通过！
仔细研究一下给出的三个条件。

1. 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符；
2. 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；
3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。

根据条件2，首先，PAT是正确的，x为空。其次，可以使用任意n个A作为x，即nAPATnA也是正确的。注意这里左右两边都是一样的x，不会出现左边空着右边有A或者左右A数量不等的情况。

接下来，根据条件3，可以写出上一步我们得到的两种情况的扩充：
PAT是正确的，那么a=0A,b=1A,c=0A,写出PAAT也是正确的。
nAPATnA是正确的，那么nAPATnAnA也是正确的，即nAPAT2nA

归纳法可知，以P、T为分界线，左面的A数量*中间的A数量等于右边的A数量。根据这个条件，再加上一些其它容易想到的条件：P、T都只有一个、没有其它字母、中间至少有一个A即可解题。

#define _CRT_SECURE_NO_WARNINGS 1；  //这是为了在VS里使用scanf函数，不知道的同学就不用管这句

#include <stdio.h>
#include <string.h>

int judge(char* arr) {//将字符串传入函数，实际上是传递该数组首元素的地址，传参写function(char str[])和function(char *str)等价，因为在 C 语言中，当数组作为函数参数传递时，它会“退化”为指针
	int arr_len = strlen(arr);
	int count_A_l = 0;
	int count_A_r = 0;
	int count_A_m = 0;
	int flag = 0;//记一下现在在统计哪里的A吧，0表示左面，1表示中间，2表示右面
	int count_P = 0;
	int count_T = 0;
	for (int i = 0; i < arr_len; i++) {
		if (arr[i] == 'A') {
			switch (flag) {
			case 0:
				count_A_l++;
				break;
			case 1:
				count_A_m++;
				break;
			case 2:
				count_A_r++;
				break;
			}
		}
		else if (arr[i] == 'P') {//可能会想到，如果是AAPAPATAA这样，是不是还要研究一下出现P时flag是否为0呢？其实不需要，最后判断P的个数是否唯一就行了
			count_P++;
			flag = 1;
		}
		else if (arr[i] == 'T') {
			count_T++;
			flag = 2;
		}
		else {
			return 0;
		}
		
	}
	if ((count_A_l * count_A_m == count_A_r)&&count_P==1&&count_T==1&&count_A_m!=0) {//别忘了count_A_m!=0
		return 1;
	}
	else {
		return 0;
	}
}

int main() {
	int a = 0;
	scanf("%d", &a);
	for (int i = 0; i < a; i++) {
		char input[101] = {};
		scanf("%s", input);
		if (judge(input) == 1) {//调用时传入数组名input即可
			printf("YES\n");
		}
		else {
			printf("NO\n");
		}
	}
	return 0;
}
